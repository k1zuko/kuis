sebentar sebelumnya saya menggunakan supabase dan ini yang sudah saya lakukan 

beritahu saya jika ada yang kurang dan siapkan perintah untuk membuat table yang dibutuhkan

1
-- Tabel untuk game rooms
CREATE TABLE game_rooms (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  room_code VARCHAR(6) UNIQUE NOT NULL,
  host_id UUID,
  title VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'waiting', -- waiting, playing, finished
  max_players INTEGER DEFAULT 40,
  duration INTEGER DEFAULT 300, -- dalam detik
  current_phase VARCHAR(20) DEFAULT 'lobby', -- lobby, quiz, minigame, finished
  questions JSONB DEFAULT '[]',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabel untuk players
CREATE TABLE players (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id UUID REFERENCES game_rooms(id) ON DELETE CASCADE,
  nickname VARCHAR(50) NOT NULL,
  character_type VARCHAR(20) DEFAULT 'robot1',
  score INTEGER DEFAULT 0,
  correct_answers INTEGER DEFAULT 0,
  is_host BOOLEAN DEFAULT FALSE,
  position_x FLOAT DEFAULT 0,
  position_y FLOAT DEFAULT 0,
  is_alive BOOLEAN DEFAULT TRUE,
  power_ups INTEGER DEFAULT 0,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabel untuk game state
CREATE TABLE game_states (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id UUID REFERENCES game_rooms(id) ON DELETE CASCADE,
  current_question INTEGER DEFAULT 0,
  phase VARCHAR(20) DEFAULT 'lobby',
  time_remaining INTEGER DEFAULT 0,
  lives_remaining INTEGER DEFAULT 3,
  target_correct_answers INTEGER DEFAULT 10,
  current_correct_answers INTEGER DEFAULT 0,
  minigame_data JSONB DEFAULT '{}',
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabel untuk answers
CREATE TABLE player_answers (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  player_id UUID REFERENCES players(id) ON DELETE CASCADE,
  room_id UUID REFERENCES game_rooms(id) ON DELETE CASCADE,
  question_index INTEGER NOT NULL,
  answer TEXT NOT NULL,
  is_correct BOOLEAN DEFAULT FALSE,
  answered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE game_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE players ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_states ENABLE ROW LEVEL SECURITY;
ALTER TABLE player_answers ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Anyone can read game rooms" ON game_rooms FOR SELECT USING (true);
CREATE POLICY "Anyone can create game rooms" ON game_rooms FOR INSERT WITH CHECK (true);
CREATE POLICY "Host can update their rooms" ON game_rooms FOR UPDATE USING (true);

CREATE POLICY "Anyone can read players" ON players FOR SELECT USING (true);
CREATE POLICY "Anyone can create players" ON players FOR INSERT WITH CHECK (true);
CREATE POLICY "Players can update themselves" ON players FOR UPDATE USING (true);

CREATE POLICY "Anyone can read game states" ON game_states FOR SELECT USING (true);
CREATE POLICY "Anyone can create game states" ON game_states FOR INSERT WITH CHECK (true);
CREATE POLICY "Anyone can update game states" ON game_states FOR UPDATE USING (true);

CREATE POLICY "Anyone can read answers" ON player_answers FOR SELECT USING (true);
CREATE POLICY "Anyone can create answers" ON player_answers FOR INSERT WITH CHECK (true);

2
-- Enable realtime for all tables
ALTER PUBLICATION supabase_realtime ADD TABLE game_rooms;
ALTER PUBLICATION supabase_realtime ADD TABLE players;
ALTER PUBLICATION supabase_realtime ADD TABLE game_states;
ALTER PUBLICATION supabase_realtime ADD TABLE player_answers;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_players_room_id ON players(room_id);
CREATE INDEX IF NOT EXISTS idx_game_states_room_id ON game_states(room_id);
CREATE INDEX IF NOT EXISTS idx_player_answers_room_id ON player_answers(room_id);
CREATE INDEX IF NOT EXISTS idx_player_answers_player_id ON player_answers(player_id);
CREATE INDEX IF NOT EXISTS idx_game_rooms_room_code ON game_rooms(room_code);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
CREATE TRIGGER update_game_rooms_updated_at BEFORE UPDATE ON game_rooms FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_game_states_updated_at BEFORE UPDATE ON game_states FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

3
-- Create player_answers table to track quiz responses
CREATE TABLE IF NOT EXISTS player_answers (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  player_id UUID REFERENCES players(id) ON DELETE CASCADE,
  room_id UUID REFERENCES game_rooms(id) ON DELETE CASCADE,
  question_index INTEGER NOT NULL,
  answer TEXT NOT NULL,
  is_correct BOOLEAN NOT NULL,
  answered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_player_answers_player_id ON player_answers(player_id);
CREATE INDEX IF NOT EXISTS idx_player_answers_room_id ON player_answers(room_id);
CREATE INDEX IF NOT EXISTS idx_player_answers_answered_at ON player_answers(answered_at);

-- Enable RLS (Row Level Security)
ALTER TABLE player_answers ENABLE ROW LEVEL SECURITY;

-- Create policy to allow all operations for now (you can restrict this later)
CREATE POLICY "Allow all operations on player_answers" ON player_answers
FOR ALL USING (true);


4
-- Optimize database for better realtime performance

-- Add indexes for better realtime query performance
CREATE INDEX IF NOT EXISTS idx_player_answers_room_question ON player_answers(room_id, question_index);
CREATE INDEX IF NOT EXISTS idx_game_states_room_phase ON game_states(room_id, phase);
CREATE INDEX IF NOT EXISTS idx_players_room_alive ON players(room_id, is_alive);

-- Function to update player stats efficiently
CREATE OR REPLACE FUNCTION update_player_stats(
  p_player_id UUID,
  p_score_increment INTEGER,
  p_correct_increment INTEGER,
  p_is_alive BOOLEAN DEFAULT TRUE
)
RETURNS void AS $$
BEGIN
  UPDATE players 
  SET 
    score = score + p_score_increment,
    correct_answers = correct_answers + p_correct_increment,
    is_alive = p_is_alive,
    updated_at = NOW()
  WHERE id = p_player_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get game summary for host
CREATE OR REPLACE FUNCTION get_game_summary(p_room_id UUID)
RETURNS TABLE(
  total_players INTEGER,
  active_players INTEGER,
  current_question INTEGER,
  phase TEXT,
  avg_score NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::INTEGER as total_players,
    COUNT(CASE WHEN is_alive THEN 1 END)::INTEGER as active_players,
    COALESCE(gs.current_question, 0) as current_question,
    COALESCE(gs.phase, 'lobby') as phase,
    COALESCE(AVG(p.score), 0) as avg_score
  FROM players p
  LEFT JOIN game_states gs ON gs.room_id = p.room_id
  WHERE p.room_id = p_room_id
  GROUP BY gs.current_question, gs.phase;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up inactive games
CREATE OR REPLACE FUNCTION cleanup_inactive_games()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete games that haven't been updated in 2 hours
  WITH deleted_rooms AS (
    DELETE FROM game_rooms 
    WHERE updated_at < NOW() - INTERVAL '2 hours'
    AND status IN ('waiting', 'finished')
    RETURNING id
  )
  SELECT COUNT(*) INTO deleted_count FROM deleted_rooms;
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update room status based on players
CREATE OR REPLACE FUNCTION update_room_status()
RETURNS TRIGGER AS $$
BEGIN
  -- Update room status based on player count
  UPDATE game_rooms 
  SET status = CASE 
    WHEN (SELECT COUNT(*) FROM players WHERE room_id = NEW.room_id AND is_alive = true) = 0 
    THEN 'finished'
    ELSE status
  END
  WHERE id = NEW.room_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for player updates
DROP TRIGGER IF EXISTS trigger_update_room_status ON players;
CREATE TRIGGER trigger_update_room_status
  AFTER UPDATE ON players
  FOR EACH ROW
  EXECUTE FUNCTION update_room_status();

-- Optimize RLS policies for better performance
DROP POLICY IF EXISTS "Optimized game room access" ON game_rooms;
CREATE POLICY "Optimized game room access" ON game_rooms
  FOR ALL USING (
    status IN ('waiting', 'playing') OR 
    updated_at > NOW() - INTERVAL '1 hour'
  );

-- Add function to get player leaderboard
CREATE OR REPLACE FUNCTION get_room_leaderboard(p_room_id UUID)
RETURNS TABLE(
  player_id UUID,
  nickname TEXT,
  score INTEGER,
  correct_answers INTEGER,
  is_alive BOOLEAN,
  rank INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.nickname,
    p.score,
    p.correct_answers,
    p.is_alive,
    ROW_NUMBER() OVER (ORDER BY p.score DESC, p.correct_answers DESC)::INTEGER as rank
  FROM players p
  WHERE p.room_id = p_room_id
  ORDER BY p.score DESC, p.correct_answers DESC;
END;
$$ LANGUAGE plpgsql;


5
-- Create tables for enhanced attack system

-- Table to track player health states for realtime sync
CREATE TABLE IF NOT EXISTS player_health_states (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  player_id UUID REFERENCES players(id) ON DELETE CASCADE,
  room_id UUID REFERENCES game_rooms(id) ON DELETE CASCADE,
  health INTEGER NOT NULL DEFAULT 3,
  max_health INTEGER NOT NULL DEFAULT 3,
  is_being_attacked BOOLEAN DEFAULT FALSE,
  last_attack_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(player_id, room_id)
);

-- Table to track attack events for realtime notifications
CREATE TABLE IF NOT EXISTS player_attacks (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  room_id UUID REFERENCES game_rooms(id) ON DELETE CASCADE,
  target_player_id UUID REFERENCES players(id) ON DELETE CASCADE,
  attacker_id UUID REFERENCES players(id) ON DELETE SET NULL, -- NULL for system attacks
  damage INTEGER NOT NULL DEFAULT 1,
  attack_type VARCHAR(50) NOT NULL DEFAULT 'wrong_answer', -- wrong_answer, manual, system
  attack_data JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE player_health_states ENABLE ROW LEVEL SECURITY;
ALTER TABLE player_attacks ENABLE ROW LEVEL SECURITY;

-- RLS Policies for player_health_states
CREATE POLICY "Anyone can read health states in active games" ON player_health_states
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM game_rooms 
      WHERE game_rooms.id = player_health_states.room_id 
      AND game_rooms.status IN ('waiting', 'playing', 'finished')
    )
  );

CREATE POLICY "Anyone can manage health states" ON player_health_states
  FOR ALL USING (true);

-- RLS Policies for player_attacks
CREATE POLICY "Anyone can read attacks in active games" ON player_attacks
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM game_rooms 
      WHERE game_rooms.id = player_attacks.room_id 
      AND game_rooms.status IN ('waiting', 'playing', 'finished')
    )
  );

CREATE POLICY "Anyone can create attacks" ON player_attacks
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM game_rooms 
      WHERE game_rooms.id = room_id 
      AND game_rooms.status IN ('playing')
    )
  );

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_player_health_states_player_room ON player_health_states(player_id, room_id);
CREATE INDEX IF NOT EXISTS idx_player_health_states_room_id ON player_health_states(room_id);
CREATE INDEX IF NOT EXISTS idx_player_attacks_room_id ON player_attacks(room_id);
CREATE INDEX IF NOT EXISTS idx_player_attacks_target_player ON player_attacks(target_player_id);
CREATE INDEX IF NOT EXISTS idx_player_attacks_created_at ON player_attacks(created_at);

-- Enable realtime for new tables
ALTER PUBLICATION supabase_realtime ADD TABLE player_health_states;
ALTER PUBLICATION supabase_realtime ADD TABLE player_attacks;

-- Function to initialize player health state
CREATE OR REPLACE FUNCTION initialize_player_health(p_player_id UUID, p_room_id UUID)
RETURNS void AS $$
BEGIN
  INSERT INTO player_health_states (player_id, room_id, health, max_health)
  VALUES (p_player_id, p_room_id, 3, 3)
  ON CONFLICT (player_id, room_id) 
  DO UPDATE SET 
    health = EXCLUDED.health,
    max_health = EXCLUDED.max_health,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- Function to handle player attack
CREATE OR REPLACE FUNCTION attack_player(
  p_room_id UUID,
  p_target_player_id UUID,
  p_damage INTEGER DEFAULT 1,
  p_attack_type VARCHAR DEFAULT 'wrong_answer',
  p_attacker_id UUID DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
  current_health INTEGER;
  new_health INTEGER;
  attack_id UUID;
BEGIN
  -- Get current health
  SELECT health INTO current_health
  FROM player_health_states
  WHERE player_id = p_target_player_id AND room_id = p_room_id;
  
  -- If no health record exists, initialize it
  IF current_health IS NULL THEN
    PERFORM initialize_player_health(p_target_player_id, p_room_id);
    current_health := 3;
  END IF;
  
  -- Calculate new health
  new_health := GREATEST(0, current_health - p_damage);
  
  -- Update health state
  UPDATE player_health_states
  SET 
    health = new_health,
    is_being_attacked = true,
    last_attack_time = NOW(),
    updated_at = NOW()
  WHERE player_id = p_target_player_id AND room_id = p_room_id;
  
  -- Create attack event
  INSERT INTO player_attacks (room_id, target_player_id, attacker_id, damage, attack_type)
  VALUES (p_room_id, p_target_player_id, p_attacker_id, p_damage, p_attack_type)
  RETURNING id INTO attack_id;
  
  -- Update player alive status if health reaches 0
  IF new_health <= 0 THEN
    UPDATE players
    SET is_alive = false
    WHERE id = p_target_player_id;
  END IF;
  
  RETURN jsonb_build_object(
    'attack_id', attack_id,
    'previous_health', current_health,
    'new_health', new_health,
    'is_alive', new_health > 0
  );
END;
$$ LANGUAGE plpgsql;

-- Function to clear attack state
CREATE OR REPLACE FUNCTION clear_attack_state(p_player_id UUID, p_room_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE player_health_states
  SET 
    is_being_attacked = false,
    updated_at = NOW()
  WHERE player_id = p_player_id AND room_id = p_room_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get room battle stats
CREATE OR REPLACE FUNCTION get_room_battle_stats(p_room_id UUID)
RETURNS TABLE(
  total_players INTEGER,
  alive_players INTEGER,
  total_attacks INTEGER,
  recent_attacks INTEGER,
  avg_health NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(p.id)::INTEGER as total_players,
    COUNT(CASE WHEN p.is_alive THEN 1 END)::INTEGER as alive_players,
    COUNT(pa.id)::INTEGER as total_attacks,
    COUNT(CASE WHEN pa.created_at > NOW() - INTERVAL '5 minutes' THEN 1 END)::INTEGER as recent_attacks,
    COALESCE(AVG(phs.health), 0) as avg_health
  FROM players p
  LEFT JOIN player_health_states phs ON phs.player_id = p.id
  LEFT JOIN player_attacks pa ON pa.target_player_id = p.id
  WHERE p.room_id = p_room_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger to initialize health state when player joins
CREATE OR REPLACE FUNCTION trigger_initialize_player_health()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM initialize_player_health(NEW.id, NEW.room_id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_player_health_init
  AFTER INSERT ON players
  FOR EACH ROW
  EXECUTE FUNCTION trigger_initialize_player_health();

-- Cleanup function for old attack data
CREATE OR REPLACE FUNCTION cleanup_old_attacks()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete attacks older than 1 hour
  WITH deleted_attacks AS (
    DELETE FROM player_attacks 
    WHERE created_at < NOW() - INTERVAL '1 hour'
    RETURNING id
  )
  SELECT COUNT(*) INTO deleted_count FROM deleted_attacks;
  
  -- Reset attack states that are stuck
  UPDATE player_health_states
  SET is_being_attacked = false
  WHERE is_being_attacked = true 
    AND last_attack_time < NOW() - INTERVAL '10 minutes';
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;


6
-- Enhance the attack system for better real-time synchronization

-- Add trigger to automatically clear attack state after some time
CREATE OR REPLACE FUNCTION auto_clear_attack_state()
RETURNS void AS $$
BEGIN
  -- Clear attack states that are older than 5 seconds
  UPDATE player_health_states
  SET is_being_attacked = false
  WHERE is_being_attacked = true 
    AND last_attack_time < NOW() - INTERVAL '5 seconds';
END;
$$ LANGUAGE plpgsql;

-- Create a function to handle wrong answer attacks
CREATE OR REPLACE FUNCTION handle_wrong_answer_attack(
  p_player_id UUID,
  p_room_id UUID,
  p_question_index INTEGER,
  p_answer TEXT,
  p_player_nickname TEXT
)
RETURNS JSONB AS $$
DECLARE
  current_health INTEGER;
  new_health INTEGER;
  attack_id UUID;
  is_eliminated BOOLEAN;
BEGIN
  -- Get or initialize current health
  SELECT health INTO current_health
  FROM player_health_states
  WHERE player_id = p_player_id AND room_id = p_room_id;
  
  -- If no health record exists, initialize it
  IF current_health IS NULL THEN
    INSERT INTO player_health_states (player_id, room_id, health, max_health)
    VALUES (p_player_id, p_room_id, 3, 3);
    current_health := 3;
  END IF;
  
  -- Calculate new health (minimum 0)
  new_health := GREATEST(0, current_health - 1);
  is_eliminated := new_health <= 0;
  
  -- Update health state with attack flag
  UPDATE player_health_states
  SET 
    health = new_health,
    is_being_attacked = true,
    last_attack_time = NOW(),
    updated_at = NOW()
  WHERE player_id = p_player_id AND room_id = p_room_id;
  
  -- Create attack event for host visualization
  INSERT INTO player_attacks (
    room_id, 
    target_player_id, 
    damage, 
    attack_type,
    attack_data
  )
  VALUES (
    p_room_id, 
    p_player_id, 
    1, 
    'wrong_answer',
    jsonb_build_object(
      'question_index', p_question_index,
      'answer', p_answer,
      'player_nickname', p_player_nickname
    )
  )
  RETURNING id INTO attack_id;
  
  -- Update player alive status if eliminated
  IF is_eliminated THEN
    UPDATE players
    SET is_alive = false
    WHERE id = p_player_id;
  END IF;
  
  -- Schedule automatic attack state clearing
  PERFORM pg_notify(
    'clear_attack_state',
    json_build_object(
      'player_id', p_player_id,
      'room_id', p_room_id,
      'delay_seconds', 3
    )::text
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'attack_id', attack_id,
    'previous_health', current_health,
    'new_health', new_health,
    'is_eliminated', is_eliminated,
    'message', CASE 
      WHEN is_eliminated THEN p_player_nickname || ' has been eliminated!'
      ELSE p_player_nickname || ' took 1 damage from zombie attack!'
    END
  );
END;
$$ LANGUAGE plpgsql;

-- Add function to get player current health
CREATE OR REPLACE FUNCTION get_player_health(p_player_id UUID, p_room_id UUID)
RETURNS INTEGER AS $$
DECLARE
  player_health INTEGER;
BEGIN
  SELECT health INTO player_health
  FROM player_health_states
  WHERE player_id = p_player_id AND room_id = p_room_id;
  
  -- Return default health if no record exists
  RETURN COALESCE(player_health, 3);
END;
$$ LANGUAGE plpgsql;

-- Add index for better performance on attack queries
CREATE INDEX IF NOT EXISTS idx_player_health_states_attack_time ON player_health_states(last_attack_time) WHERE is_being_attacked = true;
CREATE INDEX IF NOT EXISTS idx_player_attacks_created_at ON player_attacks(created_at DESC);

-- Add function to get room attack statistics
CREATE OR REPLACE FUNCTION get_room_attack_stats(p_room_id UUID)
RETURNS TABLE(
  total_attacks INTEGER,
  recent_attacks INTEGER,
  players_under_attack INTEGER,
  eliminated_players INTEGER,
  average_health NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(pa.id)::INTEGER as total_attacks,
    COUNT(CASE WHEN pa.created_at > NOW() - INTERVAL '1 minute' THEN 1 END)::INTEGER as recent_attacks,
    COUNT(CASE WHEN phs.is_being_attacked THEN 1 END)::INTEGER as players_under_attack,
    COUNT(CASE WHEN phs.health <= 0 THEN 1 END)::INTEGER as eliminated_players,
    COALESCE(AVG(phs.health), 0) as average_health
  FROM player_health_states phs
  LEFT JOIN player_attacks pa ON pa.target_player_id = phs.player_id
  WHERE phs.room_id = p_room_id;
END;
$$ LANGUAGE plpgsql;

-- Create a cleanup job for old attack states (run this periodically)
CREATE OR REPLACE FUNCTION cleanup_attack_states()
RETURNS INTEGER AS $$
DECLARE
  cleared_count INTEGER;
BEGIN
  -- Clear attack states older than 10 seconds
  UPDATE player_health_states
  SET is_being_attacked = false
  WHERE is_being_attacked = true 
    AND last_attack_time < NOW() - INTERVAL '10 seconds';
  
  GET DIAGNOSTICS cleared_count = ROW_COUNT;
  
  -- Delete old attack events (keep last 100 per room)
  DELETE FROM player_attacks
  WHERE id NOT IN (
    SELECT id FROM player_attacks
    ORDER BY created_at DESC
    LIMIT 100
  );
  
  RETURN cleared_count;
END;
$$ LANGUAGE plpgsql;


7
-- Optimize database for better realtime performance
-- Add indexes for better realtime query performance
CREATE INDEX IF NOT EXISTS idx_player_health_states_room_player ON player_health_states(room_id, player_id);
CREATE INDEX IF NOT EXISTS idx_player_health_states_updated_at ON player_health_states(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_player_attacks_room_created ON player_attacks(room_id, created_at DESC);

-- Optimize RLS policies for better performance
DROP POLICY IF EXISTS "Optimized health states access" ON player_health_states;
CREATE POLICY "Optimized health states access" ON player_health_states
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM game_rooms 
        WHERE game_rooms.id = player_health_states.room_id 
        AND game_rooms.status IN ('waiting', 'playing')
        AND game_rooms.updated_at > NOW() - INTERVAL '2 hours'
    )
);

-- Function to batch update player health states for better performance
CREATE OR REPLACE FUNCTION batch_update_player_health(
    p_room_id UUID,
    p_updates JSONB
)
RETURNS void AS $$
DECLARE
    update_record JSONB;
BEGIN
    FOR update_record IN SELECT * FROM jsonb_array_elements(p_updates)
    LOOP
        UPDATE player_health_states
        SET 
            health = (update_record->>'health')::INTEGER,
            is_being_attacked = (update_record->>'is_being_attacked')::BOOLEAN,
            last_attack_time = COALESCE((update_record->>'last_attack_time')::TIMESTAMP WITH TIME ZONE, NOW()),
            updated_at = NOW()
        WHERE player_id = (update_record->>'player_id')::UUID 
        AND room_id = p_room_id;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Optimize the attack function for better real-time performance
CREATE OR REPLACE FUNCTION handle_wrong_answer_attack_optimized(
    p_player_id UUID,
    p_room_id UUID,
    p_question_index INTEGER,
    p_answer TEXT,
    p_player_nickname TEXT
)
RETURNS JSONB AS $$
DECLARE
    current_health INTEGER;
    new_health INTEGER;
    attack_id UUID;
    is_eliminated BOOLEAN;
BEGIN
    -- Get or initialize current health with better locking
    SELECT health INTO current_health
    FROM player_health_states
    WHERE player_id = p_player_id AND room_id = p_room_id
    FOR UPDATE;

    -- If no health record exists, initialize it
    IF current_health IS NULL THEN
        INSERT INTO player_health_states (player_id, room_id, health, max_health)
        VALUES (p_player_id, p_room_id, 3, 3)
        ON CONFLICT (player_id, room_id) DO UPDATE SET
            health = EXCLUDED.health,
            max_health = EXCLUDED.max_health,
            updated_at = NOW();
        current_health := 3;
    END IF;

    -- Calculate new health (minimum 0)
    new_health := GREATEST(0, current_health - 1);
    is_eliminated := new_health <= 0;

    -- Update health state with attack flag in single query
    UPDATE player_health_states
    SET 
        health = new_health,
        is_being_attacked = true,
        last_attack_time = NOW(),
        updated_at = NOW()
    WHERE player_id = p_player_id AND room_id = p_room_id;

    -- Create attack event for host visualization
    INSERT INTO player_attacks (
        room_id, 
        target_player_id, 
        damage, 
        attack_type,
        attack_data
    ) VALUES (
        p_room_id, 
        p_player_id, 
        1, 
        'wrong_answer',
        jsonb_build_object(
            'question_index', p_question_index,
            'answer', p_answer,
            'player_nickname', p_player_nickname
        )
    ) RETURNING id INTO attack_id;

    -- Update player alive status if eliminated
    IF is_eliminated THEN
        UPDATE players
        SET is_alive = false
        WHERE id = p_player_id;
    END IF;

    RETURN jsonb_build_object(
        'success', true,
        'attack_id', attack_id,
        'previous_health', current_health,
        'new_health', new_health,
        'is_eliminated', is_eliminated,
        'message', CASE 
            WHEN is_eliminated THEN p_player_nickname || ' has been eliminated!'
            ELSE p_player_nickname || ' took 1 damage from zombie attack!'
        END
    );
END;
$$ LANGUAGE plpgsql;

-- Create function to automatically clear old attack states for better performance
CREATE OR REPLACE FUNCTION auto_cleanup_attack_states()
RETURNS void AS $$
BEGIN
    -- Clear attack states older than 5 seconds
    UPDATE player_health_states
    SET is_being_attacked = false
    WHERE is_being_attacked = true 
    AND last_attack_time < NOW() - INTERVAL '5 seconds';

    -- Delete old attack events (keep last 50 per room)
    DELETE FROM player_attacks
    WHERE id NOT IN (
        SELECT id FROM player_attacks
        ORDER BY created_at DESC
        LIMIT 50
    );
END;
$$ LANGUAGE plpgsql;

-- Create a more efficient function to get room health summary
CREATE OR REPLACE FUNCTION get_room_health_summary(p_room_id UUID)
RETURNS TABLE(
    player_id UUID,
    nickname TEXT,
    health INTEGER,
    is_being_attacked BOOLEAN,
    last_attack_time TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.nickname,
        COALESCE(phs.health, 3) as health,
        COALESCE(phs.is_being_attacked, false) as is_being_attacked,
        COALESCE(phs.last_attack_time, p.joined_at) as last_attack_time
    FROM players p
    LEFT JOIN player_health_states phs ON phs.player_id = p.id
    WHERE p.room_id = p_room_id
    ORDER BY p.joined_at;
END;
$$ LANGUAGE plpgsql;


8
-- Optimize database for better realtime performance
-- Add indexes for better realtime query performance
CREATE INDEX IF NOT EXISTS idx_player_health_states_room_player ON player_health_states(room_id, player_id);
CREATE INDEX IF NOT EXISTS idx_player_health_states_updated_at ON player_health_states(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_player_attacks_room_created ON player_attacks(room_id, created_at DESC);

-- Optimize RLS policies for better performance
DROP POLICY IF EXISTS "Optimized health states access" ON player_health_states;
CREATE POLICY "Optimized health states access" ON player_health_states
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM game_rooms 
        WHERE game_rooms.id = player_health_states.room_id 
        AND game_rooms.status IN ('waiting', 'playing')
        AND game_rooms.updated_at > NOW() - INTERVAL '2 hours'
    )
);

-- Function to batch update player health states for better performance
CREATE OR REPLACE FUNCTION batch_update_player_health(
    p_room_id UUID,
    p_updates JSONB
)
RETURNS void AS $$
DECLARE
    update_record JSONB;
BEGIN
    FOR update_record IN SELECT * FROM jsonb_array_elements(p_updates)
    LOOP
        UPDATE player_health_states
        SET 
            health = (update_record->>'health')::INTEGER,
            is_being_attacked = (update_record->>'is_being_attacked')::BOOLEAN,
            last_attack_time = COALESCE((update_record->>'last_attack_time')::TIMESTAMP WITH TIME ZONE, NOW()),
            updated_at = NOW()
        WHERE player_id = (update_record->>'player_id')::UUID 
        AND room_id = p_room_id;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Ensure attack function only deals exactly 1 damage
CREATE OR REPLACE FUNCTION handle_wrong_answer_attack_optimized(
    p_player_id UUID,
    p_room_id UUID,
    p_question_index INTEGER,
    p_answer TEXT,
    p_player_nickname TEXT
)
RETURNS JSONB AS $$
DECLARE
    current_health INTEGER;
    new_health INTEGER;
    attack_id UUID;
    is_eliminated BOOLEAN;
    damage_amount INTEGER := 1; -- Ensure exactly 1 damage
BEGIN
    -- Get or initialize current health with better locking
    SELECT health INTO current_health
    FROM player_health_states
    WHERE player_id = p_player_id AND room_id = p_room_id
    FOR UPDATE;

    -- If no health record exists, initialize it
    IF current_health IS NULL THEN
        INSERT INTO player_health_states (player_id, room_id, health, max_health)
        VALUES (p_player_id, p_room_id, 3, 3)
        ON CONFLICT (player_id, room_id) DO UPDATE SET
            health = EXCLUDED.health,
            max_health = EXCLUDED.max_health,
            updated_at = NOW();
        current_health := 3;
    END IF;

    -- Calculate new health with exactly 1 damage
    new_health := GREATEST(0, current_health - damage_amount);
    is_eliminated := new_health <= 0;

    -- Update health state with attack flag in single query
    UPDATE player_health_states
    SET 
        health = new_health,
        is_being_attacked = true,
        last_attack_time = NOW(),
        updated_at = NOW()
    WHERE player_id = p_player_id AND room_id = p_room_id;

    -- Create attack event for host visualization with exactly 1 damage
    INSERT INTO player_attacks (
        room_id, 
        target_player_id, 
        damage, 
        attack_type,
        attack_data
    ) VALUES (
        p_room_id, 
        p_player_id, 
        damage_amount, -- Exactly 1 damage
        'wrong_answer',
        jsonb_build_object(
            'question_index', p_question_index,
            'answer', p_answer,
            'player_nickname', p_player_nickname,
            'damage_dealt', damage_amount
        )
    ) RETURNING id INTO attack_id;

    -- Update player alive status if eliminated
    IF is_eliminated THEN
        UPDATE players
        SET is_alive = false
        WHERE id = p_player_id;
    END IF;

    RETURN jsonb_build_object(
        'success', true,
        'attack_id', attack_id,
        'previous_health', current_health,
        'new_health', new_health,
        'damage_dealt', damage_amount,
        'is_eliminated', is_eliminated,
        'message', CASE 
            WHEN is_eliminated THEN p_player_nickname || ' telah dieliminasi!'
            ELSE p_player_nickname || ' terkena 1 damage dari serangan zombie!'
        END
    );
END;
$$ LANGUAGE plpgsql;

-- Also update the original function to ensure 1 damage
CREATE OR REPLACE FUNCTION handle_wrong_answer_attack(
  p_player_id UUID,
  p_room_id UUID,
  p_question_index INTEGER,
  p_answer TEXT,
  p_player_nickname TEXT)
RETURNS JSONB AS $$
DECLARE
  current_health INTEGER;
  new_health INTEGER;
  attack_id UUID;
  is_eliminated BOOLEAN;
  damage_amount INTEGER := 1; -- Exactly 1 damage
BEGIN
-- Get or initialize current health
SELECT health INTO current_health
FROM player_health_states
WHERE player_id = p_player_id AND room_id = p_room_id;

-- If no health record exists, initialize it  
  IF current_health IS NULL THEN
    INSERT INTO player_health_states (player_id, room_id, health, max_health)
    VALUES (p_player_id, p_room_id, 3, 3);
    current_health := 3;
END IF;

-- Calculate new health with exactly 1 damage
  new_health := GREATEST(0, current_health - damage_amount);
  is_eliminated := new_health <= 0;

-- Update health state with attack flag  
  UPDATE player_health_states  
  SET     
    health = new_health,
    is_being_attacked = true,
    last_attack_time = NOW(),
    updated_at = NOW()
WHERE player_id = p_player_id AND room_id = p_room_id;

-- Create attack event for host visualization  
  INSERT INTO player_attacks (    
    room_id,     
    target_player_id,     
    damage,     
    attack_type,
    attack_data)  
  VALUES (    
    p_room_id,     
    p_player_id, 
    damage_amount, -- Exactly 1 damage
    'wrong_answer',
    jsonb_build_object(
      'question_index', p_question_index,
      'answer', p_answer,
      'player_nickname', p_player_nickname,
      'damage_dealt', damage_amount))
RETURNING id INTO attack_id;

-- Update player alive status if eliminated  
  IF is_eliminated THEN    
    UPDATE players    
    SET is_alive = false
    WHERE id = p_player_id;
END IF;

  RETURN jsonb_build_object(
    'success', true,
    'attack_id', attack_id,
    'previous_health', current_health,
    'new_health', new_health,
    'damage_dealt', damage_amount,
    'is_eliminated', is_eliminated,
    'message', CASE 
      WHEN is_eliminated THEN p_player_nickname || ' telah dieliminasi!'
      ELSE p_player_nickname || ' terkena 1 damage dari serangan zombie!'
    END);
END;
$$ LANGUAGE plpgsql;

-- Create function to automatically clear old attack states for better performance
CREATE OR REPLACE FUNCTION auto_cleanup_attack_states()
RETURNS void AS $$
BEGIN
    -- Clear attack states older than 5 seconds
    UPDATE player_health_states
    SET is_being_attacked = false
    WHERE is_being_attacked = true 
    AND last_attack_time < NOW() - INTERVAL '5 seconds';

    -- Delete old attack events (keep last 50 per room)
    DELETE FROM player_attacks
    WHERE id NOT IN (
        SELECT id FROM player_attacks
        ORDER BY created_at DESC
        LIMIT 50
    );
END;
$$ LANGUAGE plpgsql;

-- Create a more efficient function to get room health summary
CREATE OR REPLACE FUNCTION get_room_health_summary(p_room_id UUID)
RETURNS TABLE(
    player_id UUID,
    nickname TEXT,
    health INTEGER,
    is_being_attacked BOOLEAN,
    last_attack_time TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.nickname,
        COALESCE(phs.health, 3) as health,
        COALESCE(phs.is_being_attacked, false) as is_being_attacked,
        COALESCE(phs.last_attack_time, p.joined_at) as last_attack_time
    FROM players p
    LEFT JOIN player_health_states phs ON phs.player_id = p.id
    WHERE p.room_id = p_room_id
    ORDER BY p.joined_at;
END;
$$ LANGUAGE plpgsql;

9
-- Create game_completions table for tracking player results
CREATE TABLE IF NOT EXISTS game_completions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    player_id UUID NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    room_id UUID NOT NULL REFERENCES game_rooms(id) ON DELETE CASCADE,
    final_health INTEGER NOT NULL DEFAULT 0,
    correct_answers INTEGER NOT NULL DEFAULT 0,
    total_questions_answered INTEGER NOT NULL DEFAULT 0,
    is_eliminated BOOLEAN NOT NULL DEFAULT false,
    completion_type TEXT NOT NULL DEFAULT 'partial', -- 'completed', 'eliminated', 'partial'
    completed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_game_completions_room_id ON game_completions(room_id);
CREATE INDEX IF NOT EXISTS idx_game_completions_player_id ON game_completions(player_id);
CREATE INDEX IF NOT EXISTS idx_game_completions_completed_at ON game_completions(completed_at DESC);

-- Enable RLS
ALTER TABLE game_completions ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Game completions are viewable by anyone in the same room" ON game_completions
FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM game_rooms 
        WHERE game_rooms.id = game_completions.room_id 
        AND game_rooms.status IN ('waiting', 'playing', 'finished')
    )
);

CREATE POLICY "Players can insert their own game completions" ON game_completions
FOR INSERT WITH CHECK (true); -- Allow inserts from authenticated users

-- Function to get player health (if not exists)
CREATE OR REPLACE FUNCTION get_player_health(
    p_player_id UUID,
    p_room_id UUID
)
RETURNS INTEGER AS $$
DECLARE
    current_health INTEGER;
BEGIN
    SELECT health INTO current_health
    FROM player_health_states
    WHERE player_id = p_player_id AND room_id = p_room_id;
    
    -- If no health record exists, return default health
    IF current_health IS NULL THEN
        RETURN 3;
    END IF;
    
    RETURN current_health;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up old game completions (optional)
CREATE OR REPLACE FUNCTION cleanup_old_game_completions()
RETURNS void AS $$
BEGIN
    -- Delete completions older than 7 days
    DELETE FROM game_completions
    WHERE completed_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

10
-- Enhance database for better results page performance

-- Add indexes for better query performance on results page
CREATE INDEX IF NOT EXISTS idx_game_completions_room_completed ON game_completions(room_id, completed_at DESC);
CREATE INDEX IF NOT EXISTS idx_game_completions_completion_type ON game_completions(completion_type);
CREATE INDEX IF NOT EXISTS idx_players_room_score ON players(room_id, score DESC);
CREATE INDEX IF NOT EXISTS idx_players_room_correct ON players(room_id, correct_answers DESC);

-- Function to get detailed room results
CREATE OR REPLACE FUNCTION get_room_results_summary(p_room_id UUID)
RETURNS TABLE(
    total_completions INTEGER,
    perfect_scores INTEGER,
    eliminations INTEGER,
    average_score NUMERIC,
    average_correct NUMERIC,
    completion_rate NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_completions,
        COUNT(CASE WHEN completion_type = 'completed' AND correct_answers = total_questions_answered THEN 1 END)::INTEGER as perfect_scores,
        COUNT(CASE WHEN is_eliminated THEN 1 END)::INTEGER as eliminations,
        COALESCE(AVG(correct_answers), 0) as average_score,
        COALESCE(AVG(correct_answers), 0) as average_correct,
        CASE 
            WHEN COUNT(*) > 0 THEN (COUNT(CASE WHEN completion_type = 'completed' THEN 1 END)::NUMERIC / COUNT(*)::NUMERIC) * 100
            ELSE 0
        END as completion_rate
    FROM game_completions
    WHERE room_id = p_room_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get player performance comparison
CREATE OR REPLACE FUNCTION get_player_performance_rank(
    p_room_id UUID,
    p_player_correct INTEGER,
    p_player_health INTEGER
)
RETURNS TABLE(
    player_rank INTEGER,
    total_players INTEGER,
    percentile NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH ranked_players AS (
        SELECT 
            ROW_NUMBER() OVER (
                ORDER BY correct_answers DESC, final_health DESC, completed_at ASC
            ) as rank,
            correct_answers,
            final_health
        FROM game_completions
        WHERE room_id = p_room_id
    ),
    player_position AS (
        SELECT rank
        FROM ranked_players
        WHERE correct_answers = p_player_correct AND final_health = p_player_health
        LIMIT 1
    ),
    total_count AS (
        SELECT COUNT(*) as total FROM ranked_players
    )
    SELECT 
        COALESCE(pp.rank, 999)::INTEGER as player_rank,
        tc.total::INTEGER as total_players,
        CASE 
            WHEN tc.total > 0 THEN ((tc.total - COALESCE(pp.rank, tc.total))::NUMERIC / tc.total::NUMERIC) * 100
            ELSE 0
        END as percentile
    FROM total_count tc
    LEFT JOIN player_position pp ON true;
END;
$$ LANGUAGE plpgsql;

-- Function to get recent game activity for realtime updates
CREATE OR REPLACE FUNCTION get_recent_game_activity(p_room_id UUID, p_limit INTEGER DEFAULT 10)
RETURNS TABLE(
    activity_type TEXT,
    player_nickname TEXT,
    activity_data JSONB,
    activity_time TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    (
        -- Recent completions
        SELECT 
            'completion'::TEXT as activity_type,
            p.nickname as player_nickname,
            jsonb_build_object(
                'correct_answers', gc.correct_answers,
                'final_health', gc.final_health,
                'is_eliminated', gc.is_eliminated,
                'completion_type', gc.completion_type
            ) as activity_data,
            gc.completed_at as activity_time
        FROM game_completions gc
        JOIN players p ON p.id = gc.player_id
        WHERE gc.room_id = p_room_id
        
        UNION ALL
        
        -- Recent attacks
        SELECT 
            'attack'::TEXT as activity_type,
            p.nickname as player_nickname,
            jsonb_build_object(
                'damage', pa.damage,
                'attack_type', pa.attack_type,
                'attack_data', pa.attack_data
            ) as activity_data,
            pa.created_at as activity_time
        FROM player_attacks pa
        JOIN players p ON p.id = pa.target_player_id
        WHERE pa.room_id = p_room_id
    )
    ORDER BY activity_time DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Enable realtime for game_completions if not already enabled
ALTER PUBLICATION supabase_realtime ADD TABLE game_completions;

-- Create trigger to update room status when game is completed
CREATE OR REPLACE FUNCTION update_room_on_completion()
RETURNS TRIGGER AS $$
BEGIN
    -- Update room's updated_at timestamp for realtime sync
    UPDATE game_rooms 
    SET updated_at = NOW()
    WHERE id = NEW.room_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for game completions
DROP TRIGGER IF EXISTS trigger_room_completion_update ON game_completions;
CREATE TRIGGER trigger_room_completion_update
    AFTER INSERT OR UPDATE ON game_completions
    FOR EACH ROW
    EXECUTE FUNCTION update_room_on_completion();

-- Optimize RLS policies for results page
DROP POLICY IF EXISTS "Game completions viewable by room participants" ON game_completions;
CREATE POLICY "Game completions viewable by room participants" ON game_completions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM game_rooms 
            WHERE game_rooms.id = game_completions.room_id 
            AND game_rooms.status IN ('playing', 'finished')
            AND game_rooms.updated_at > NOW() - INTERVAL '24 hours'
        )
    );

-- Function to cleanup old results data (run periodically)
CREATE OR REPLACE FUNCTION cleanup_old_results()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Delete game completions older than 7 days
    WITH deleted_completions AS (
        DELETE FROM game_completions 
        WHERE completed_at < NOW() - INTERVAL '7 days'
        RETURNING id
    )
    SELECT COUNT(*) INTO deleted_count FROM deleted_completions;
    
    -- Also cleanup related old attack data
    DELETE FROM player_attacks 
    WHERE created_at < NOW() - INTERVAL '7 days';
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;


11
-- Drop existing functions first to avoid type conflicts
DROP FUNCTION IF EXISTS get_room_leaderboard(UUID);
DROP FUNCTION IF EXISTS get_room_battle_stats(UUID);

-- Create the leaderboard function with consistent field names
CREATE OR REPLACE FUNCTION get_room_leaderboard(p_room_id UUID)
RETURNS TABLE(
  id UUID,  -- Changed from player_id to id for consistency
  nickname TEXT,
  score INTEGER,
  correct_answers INTEGER,
  is_alive BOOLEAN,
  rank INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.nickname,
    p.score,
    p.correct_answers,
    p.is_alive,
    ROW_NUMBER() OVER (ORDER BY p.score DESC, p.correct_answers DESC)::INTEGER as rank
  FROM players p
  WHERE p.room_id = p_room_id
  ORDER BY p.score DESC, p.correct_answers DESC;
END;
$$ LANGUAGE plpgsql;

-- Create the battle stats function with better error handling
CREATE OR REPLACE FUNCTION get_room_battle_stats(p_room_id UUID)
RETURNS TABLE(
  total_players INTEGER,
  alive_players INTEGER,
  total_attacks INTEGER,
  recent_attacks INTEGER,
  average_health NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(p.id)::INTEGER as total_players,
    COUNT(CASE WHEN p.is_alive THEN 1 END)::INTEGER as alive_players,
    COALESCE(COUNT(pa.id), 0)::INTEGER as total_attacks,
    COALESCE(COUNT(CASE WHEN pa.created_at > NOW() - INTERVAL '5 minutes' THEN 1 END), 0)::INTEGER as recent_attacks,
    COALESCE(AVG(phs.health), 3.0) as average_health
  FROM players p
  LEFT JOIN player_health_states phs ON phs.player_id = p.id AND phs.room_id = p.room_id
  LEFT JOIN player_attacks pa ON pa.target_player_id = p.id
  WHERE p.room_id = p_room_id
  GROUP BY p.room_id;
  
  -- If no data found, return default values
  IF NOT FOUND THEN
    RETURN QUERY
    SELECT 
      0::INTEGER as total_players,
      0::INTEGER as alive_players,
      0::INTEGER as total_attacks,
      0::INTEGER as recent_attacks,
      3.0::NUMERIC as average_health;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Test the functions to make sure they work
-- SELECT * FROM get_room_leaderboard('00000000-0000-0000-0000-000000000000');
-- SELECT * FROM get_room_battle_stats('00000000-0000-0000-0000-000000000000');

-- Grant execute permissions if needed
GRANT EXECUTE ON FUNCTION get_room_leaderboard(UUID) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION get_room_battle_stats(UUID) TO anon, authenticated;

12

ALTER TABLE game_states
ADD COLUMN created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL;

13

ALTER TABLE game_states
ADD COLUMN current_question_index INTEGER DEFAULT 0 NOT NULL;

14
ALTER TABLE game_states
ADD COLUMN status TEXT DEFAULT 'playing' NOT NULL;

15
DROP FUNCTION IF EXISTS get_room_leaderboard(UUID);

CREATE OR REPLACE FUNCTION get_room_leaderboard(p_room_id UUID)
RETURNS TABLE(
  id UUID,
  nickname VARCHAR(50),
  score INTEGER,
  correct_answers INTEGER,
  is_alive BOOLEAN,
  rank INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.nickname::VARCHAR(50),
    gc.correct_answers * 100 AS score,
    gc.correct_answers,
    NOT gc.is_eliminated AS is_alive,
    ROW_NUMBER() OVER (ORDER BY gc.correct_answers DESC, gc.final_health DESC)::INTEGER AS rank
  FROM game_completions gc
  JOIN players p ON p.id = gc.player_id
  WHERE gc.room_id = p_room_id
  ORDER BY gc.correct_answers DESC, gc.final_health DESC;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION get_room_leaderboard(UUID) TO anon, authenticated;

16
DROP FUNCTION IF EXISTS get_recent_game_activity(UUID, INTEGER);

CREATE OR REPLACE FUNCTION get_recent_game_activity(p_room_id UUID, p_limit INTEGER DEFAULT 10)
RETURNS TABLE(
  activity_type VARCHAR(50),
  player_nickname VARCHAR(50),
  activity_data JSONB,
  activity_time TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  (
    SELECT 
      'completion'::VARCHAR(50) AS activity_type,
      p.nickname::VARCHAR(50) AS player_nickname,
      jsonb_build_object(
        'correct_answers', gc.correct_answers,
        'final_health', gc.final_health,
        'is_eliminated', gc.is_eliminated,
        'completion_type', gc.completion_type
      ) AS activity_data,
      gc.completed_at AS activity_time
    FROM game_completions gc
    JOIN players p ON p.id = gc.player_id
    WHERE gc.room_id = p_room_id
    
    UNION ALL
    
    SELECT 
      pa.attack_type AS activity_type,
      p.nickname::VARCHAR(50) AS player_nickname,
      jsonb_build_object(
        'damage', pa.damage,
        'attack_type', pa.attack_type,
        'attack_data', pa.attack_data
      ) AS activity_data,
      pa.created_at AS activity_time
    FROM player_attacks pa
    JOIN players p ON p.id = pa.target_player_id
    WHERE pa.room_id = p_room_id
  )
  ORDER BY activity_time DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION get_recent_game_activity(UUID, INTEGER) TO anon, authenticated;


17
DROP FUNCTION IF EXISTS get_room_battle_stats(UUID);

CREATE OR REPLACE FUNCTION get_room_battle_stats(p_room_id UUID)
RETURNS TABLE(
  total_players INTEGER,
  alive_players INTEGER,
  total_attacks INTEGER,
  recent_attacks INTEGER,
  average_health NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(p.id)::INTEGER AS total_players,
    COUNT(CASE WHEN p.is_alive THEN 1 END)::INTEGER AS alive_players,
    COALESCE(COUNT(pa.id), 0)::INTEGER AS total_attacks,
    COALESCE(COUNT(CASE WHEN pa.created_at > NOW() - INTERVAL '5 minutes' THEN 1 END), 0)::INTEGER AS recent_attacks,
    COALESCE(AVG(phs.health), 3.0) AS average_health
  FROM players p
  LEFT JOIN player_health_states phs ON phs.player_id = p.id AND phs.room_id = p_room_id
  LEFT JOIN player_attacks pa ON pa.target_player_id = p.id
  WHERE p.room_id = p_room_id
  GROUP BY p.room_id;
  
  IF NOT FOUND THEN
    RETURN QUERY
    SELECT 
      0::INTEGER AS total_players,
      0::INTEGER AS alive_players,
      0::INTEGER AS total_attacks,
      0::INTEGER AS recent_attacks,
      3.0::NUMERIC AS average_health;
  END IF;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION get_room_battle_stats(UUID) TO anon, authenticated;



ini adalah supabase.ts saya 
import { createClient } from "@supabase/supabase-js"

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export const supabase = createClient(supabaseUrl, supabaseAnonKey)

export type GameRoom = {
  countdown_start: string | number | Date
  id: string
  room_code: string
  host_player_id: string | null // Combines host_id and host_player_id
  question_set_id: string | null // From second definition, for question set reference
  title: string | null // From first definition, optional
  status: "waiting" | "playing" | "finished"
  current_phase: "lobby" | "quiz" | "minigame" | "finished"
  max_players: number // Used in HostPage.tsx for player count display
  duration: number // Used in HostPage.tsx for duration display
  questions: any[] // Used in HostPage.tsx, can be refined later
  created_at: string
  updated_at: string
}

export type Player = {
  id: string
  room_id: string
  nickname: string
  character_type: string
  health: number // Used in LobbyPhase.tsx via SoulStatus
  max_health: number // Used in LobbyPhase.tsx via SoulStatus
  score: number // Used in LobbyPhase.tsx via SoulStatus
  correct_answers: number
  wrong_answers: number // From first definition
  is_host: boolean // Used in LobbyPhase.tsx and HostPage.tsx
  is_alive: boolean
  power_ups: number // From first definition
  position_x: number // From first definition
  position_y: number // From first definition
  created_at: string
  updated_at: string
  joined_at: string // Used in HostPage.tsx for player join time
}

export type GameState = {
  id: string
  room_id: string
  current_question_index: number // From second definition
  phase: "lobby" | "quiz" | "minigame" | "finished" // From first definition
  time_remaining: number
  lives_remaining: number // From first definition
  target_correct_answers: number // From first definition
  current_correct_answers: number // From first definition
  minigame_data: any // From first definition
  status: "waiting" | "playing" | "finished" // From second definition
  created_at: string
  updated_at: string
}

export type SafeZone = {
  x: number
  y: number
  width: number
  height: number
  occupied: number
  required: number
}

export type PlayerHealthState = {
  id: string
  player_id: string
  room_id: string
  health: number
  is_alive: boolean // From second definition
  is_being_attacked: boolean // From first definition
  last_attack_time: string // From first definition
  created_at: string
  updated_at: string
}

export type PlayerAttack = {
  id: string
  room_id: string
  attacker_player_id: string // From second definition
  target_player_id: string
  damage: number
  attack_type: string
  attack_data: any // From second definition
  created_at: string
}

export type PlayerAnswer = {
  id: string
  player_id: string
  room_id: string
  question_index: number
  answer: string
  is_correct: boolean
  answered_at: string
}

ini useGameData.ts
"use client"

import { useState, useEffect, useCallback } from "react"
import { supabase } from "@/lib/supabase"

// Export interfaces
export interface TransformedPlayer {
  id: string
  nickname: string
  health: number
  maxHealth: number
  score: number
  correctAnswers: number
  isHost?: boolean
  isReady?: boolean
  hasAnswered?: boolean
  status?: "alive" | "dead" | "spectating"
  character_type?: string
}

export interface TransformedGameState {
  phase: "lobby" | "quiz" | "minigame" | "finished" | "results"
  currentQuestion: number
  timeRemaining: number
  currentCorrectAnswers?: number
  targetCorrectAnswers?: number
}

export interface TransformedRoom {
  code: string
  hostId: string
  id: string
  status: string
  current_phase?: string
  questions?: any[]
}

export function useGameData(roomCode: string | undefined, nickname: string | null) {
  const [room, setRoom] = useState<TransformedRoom | null>(null)
  const [gameState, setGameState] = useState<TransformedGameState | null>(null)
  const [players, setPlayers] = useState<TransformedPlayer[]>([])
  const [currentPlayer, setCurrentPlayer] = useState<TransformedPlayer | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [isSoloMode, setIsSoloMode] = useState(false)

  const loadGameData = useCallback(async () => {
    if (!roomCode) return

    try {
      setError(null)
      console.log(`Loading game data for room: ${roomCode}`)

      // Fetch room data
      const { data: roomData, error: roomError } = await supabase
        .from("game_rooms")
        .select("*")
        .eq("room_code", roomCode.toUpperCase())
        .single()

      if (roomError || !roomData) {
        console.error("Room not found:", roomError)
        setError("Room not found")
        setIsLoading(false)
        return
      }

      // Fetch game state
      const { data: gameStateData, error: gameStateError } = await supabase
        .from("game_states")
        .select("*")
        .eq("room_id", roomData.id)
        .order("updated_at", { ascending: false })
        .limit(1)
        .single()

      // Create game state if it doesn't exist
      let finalGameState = gameStateData
      if (gameStateError || !gameStateData) {
        console.log("Creating initial game state...")
        const { data: newGameState, error: createError } = await supabase
          .from("game_states")
          .insert({
            room_id: roomData.id,
            current_question: 0,
            phase: "lobby",
            time_remaining: 30,
            lives_remaining: 3,
            target_correct_answers: 5,
            current_correct_answers: 0,
            minigame_data: {},
          })
          .select()
          .single()

        if (createError) {
          console.error("Failed to create game state:", createError)
        } else {
          finalGameState = newGameState
        }
      }

      // Fetch players
      const { data: playersData, error: playersError } = await supabase
        .from("players")
        .select("*")
        .eq("room_id", roomData.id)
        .order("joined_at", { ascending: true })

      if (playersError) {
        console.error("Error fetching players:", playersError)
      }

      // Transform room data
      const transformedRoom: TransformedRoom = {
        code: roomData.room_code,
        hostId: roomData.host_id || "",
        id: roomData.id,
        status: roomData.status,
        current_phase: roomData.current_phase,
        questions: roomData.questions || [],
      }

      // Transform game state
      let phase: TransformedGameState["phase"] = "lobby"
      if (roomData.status === "playing") {
        phase = (roomData.current_phase as TransformedGameState["phase"]) || "quiz"
      } else if (roomData.status === "finished") {
        phase = "finished"
      }

      const transformedGameState: TransformedGameState = {
        phase: phase,
        currentQuestion: finalGameState?.current_question || 0,
        timeRemaining: finalGameState?.time_remaining || 30,
        currentCorrectAnswers: finalGameState?.current_correct_answers || 0,
        targetCorrectAnswers: finalGameState?.target_correct_answers || 5,
      }

      // Transform players data
      const transformedPlayers: TransformedPlayer[] = (playersData || []).map((player) => ({
        id: player.id,
        nickname: player.nickname,
        health: 3, // Default health
        maxHealth: 3,
        score: player.score || 0,
        correctAnswers: player.correct_answers || 0,
        isHost: player.is_host,
        isReady: true, // Default ready state
        hasAnswered: false,
        status: player.is_alive ? "alive" : "dead",
        character_type: player.character_type,
      }))

      // Find or create current player
      let transformedCurrentPlayer: TransformedPlayer | null = null
      if (nickname) {
        transformedCurrentPlayer = transformedPlayers.find((p) => p.nickname === nickname) || null

        // If player not found and we have a nickname, try to create player
        if (!transformedCurrentPlayer && roomData.status === "waiting") {
          console.log(`Creating new player: ${nickname}`)
          const { data: newPlayer, error: playerError } = await supabase
            .from("players")
            .insert({
              room_id: roomData.id,
              nickname: nickname,
              character_type: `robot${Math.floor(Math.random() * 5) + 1}`,
              score: 0,
              correct_answers: 0,
              is_host: transformedPlayers.length === 0, // First player is host
              is_alive: true,
            })
            .select()
            .single()

          if (playerError) {
            console.error("Failed to create player:", playerError)
            setError("Failed to join game")
          } else {
            transformedCurrentPlayer = {
              id: newPlayer.id,
              nickname: newPlayer.nickname,
              health: 3,
              maxHealth: 3,
              score: 0,
              correctAnswers: 0,
              isHost: newPlayer.is_host,
              isReady: true,
              hasAnswered: false,
              status: "alive",
              character_type: newPlayer.character_type,
            }
            transformedPlayers.push(transformedCurrentPlayer)
          }
        }
      }

      // Set all state
      setRoom(transformedRoom)
      setGameState(transformedGameState)
      setPlayers(transformedPlayers)
      setCurrentPlayer(transformedCurrentPlayer)
      setIsSoloMode(roomCode.startsWith("SOLO_") || !nickname)
      setIsLoading(false)

      console.log("Game data loaded successfully:", {
        room: transformedRoom,
        gameState: transformedGameState,
        players: transformedPlayers.length,
        currentPlayer: transformedCurrentPlayer?.nickname,
      })
    } catch (error) {
      console.error("Error loading game data:", error)
      setError("Failed to load game data")
      setIsLoading(false)
    }
  }, [roomCode, nickname])

  // Setup realtime subscriptions
  useEffect(() => {
    if (!room) return

    console.log(`Setting up realtime subscriptions for room ${room.id}`)

    // Subscribe to room changes
    const roomChannel = supabase
      .channel(`room-${room.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "game_rooms",
          filter: `id=eq.${room.id}`,
        },
        (payload) => {
          console.log("Room updated:", payload)
          loadGameData()
        },
      )
      .subscribe()

    // Subscribe to game state changes
    const stateChannel = supabase
      .channel(`state-${room.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "game_states",
          filter: `room_id=eq.${room.id}`,
        },
        (payload) => {
          console.log("Game state updated:", payload)
          loadGameData()
        },
      )
      .subscribe()

    // Subscribe to players changes
    const playersChannel = supabase
      .channel(`players-${room.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "players",
          filter: `room_id=eq.${room.id}`,
        },
        (payload) => {
          console.log("Players updated:", payload)
          loadGameData()
        },
      )
      .subscribe()

    // Subscribe to player answers for realtime feedback
    const answersChannel = supabase
      .channel(`answers-${room.id}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "player_answers",
          filter: `room_id=eq.${room.id}`,
        },
        (payload) => {
          console.log("New answer submitted:", payload)
          // This will trigger updates on the host page
        },
      )
      .subscribe()

    return () => {
      console.log("Cleaning up subscriptions")
      supabase.removeChannel(roomChannel)
      supabase.removeChannel(stateChannel)
      supabase.removeChannel(playersChannel)
      supabase.removeChannel(answersChannel)
    }
  }, [room, loadGameData])

  // Initial data load
  useEffect(() => {
    if (roomCode) {
      loadGameData()
    }
  }, [loadGameData, roomCode])

  const refetch = useCallback(() => {
    console.log("Refetching game data...")
    setIsLoading(true)
    loadGameData()
  }, [loadGameData])

  return {
    room,
    gameState,
    players,
    currentPlayer,
    isLoading,
    error,
    isSoloMode,
    refetch,
  }
}


useGameLogic.ts 

"use client"

import { useState, useCallback, useRef, useEffect } from "react"
import { supabase } from "@/lib/supabase"

interface GameLogicProps {
  room: any
  gameState: any
  players: any[]
  currentPlayer: any
}

export function useGameLogic({ room, gameState, players, currentPlayer }: GameLogicProps) {
  // Component mount tracking
  const isMountedRef = useRef(true)

  const [isGameOver, setIsGameOver] = useState(false)
  const [showCaptureAnimation, setShowCaptureAnimation] = useState(false)
  const [wrongAnswers, setWrongAnswers] = useState(0)
  const [isSubmitting, setIsSubmitting] = useState(false)

  const toggleReady = useCallback(async () => {
    if (!currentPlayer || !room || isSubmitting) {
      return false
    }

    try {
      setIsSubmitting(true)

      const { error } = await supabase
        .from("players")
        .update({
          is_ready: !currentPlayer.isReady,
        })
        .eq("id", currentPlayer.id)

      if (error) {
        console.error("Error toggling ready state:", error)
        return false
      }

      return true
    } catch (error) {
      console.error("Error in toggleReady:", error)
      return false
    } finally {
      if (isMountedRef.current) {
        setIsSubmitting(false)
      }
    }
  }, [currentPlayer, room, isSubmitting])

  const submitAnswer = useCallback(
    async (answer: string, isCorrect: boolean) => {
      // Enhanced validation
      if (!currentPlayer?.id || !room?.id || !gameState || isSubmitting) {
        console.log("submitAnswer: validation failed", {
          hasCurrentPlayer: !!currentPlayer?.id,
          hasRoom: !!room?.id,
          hasGameState: !!gameState,
          isSubmitting,
        })
        return false
      }

      try {
        setIsSubmitting(true)
        console.log(`🎯 Submitting answer: "${answer}", correct: ${isCorrect}`)

        // 1. Insert answer to database
        const { error: answerError } = await supabase.from("player_answers").insert({
          player_id: currentPlayer.id,
          room_id: room.id,
          question_index: gameState.currentQuestion || 0,
          answer: answer,
          is_correct: isCorrect,
        })

        if (answerError) {
          console.error("❌ Error submitting answer:", answerError)
          return false
        }

        console.log("✅ Answer submitted to database successfully")

        // 2. Update player stats
        const updates: any = {}

        if (isCorrect) {
          updates.correct_answers = (currentPlayer.correctAnswers || 0) + 1
          updates.score = (currentPlayer.score || 0) + 10
          console.log("🎉 Correct answer - updating stats:", updates)
        } else {
          updates.wrong_answers = (currentPlayer.wrongAnswers || 0) + 1
          console.log("💀 Wrong answer - updating stats:", updates)

          // Update local state for wrong answers
          if (isMountedRef.current) {
            setWrongAnswers((prev) => prev + 1)
          }

          // 3. Handle health system for wrong answers
          try {
            console.log("🩺 Processing health update for wrong answer...")

            // Get or create current health state
            let { data: healthState, error: healthError } = await supabase
              .from("player_health_states")
              .select("*")
              .eq("player_id", currentPlayer.id)
              .eq("room_id", room.id)
              .single()

            if (healthError && healthError.code !== "PGRST116") {
              console.error("Error fetching health state:", healthError)
            }

            // Create health state if it doesn't exist
            if (!healthState) {
              console.log("🆕 Creating new health state...")
              const { data: newHealthState, error: createError } = await supabase
                .from("player_health_states")
                .insert({
                  player_id: currentPlayer.id,
                  room_id: room.id,
                  health: 2, // Start with 3, reduce to 2 for first wrong answer
                  is_being_attacked: true,
                  last_attack_time: new Date().toISOString(),
                })
                .select()
                .single()

              if (createError) {
                console.error("❌ Error creating health state:", createError)
              } else {
                healthState = newHealthState
                console.log("✅ Health state created:", healthState)
              }
            } else {
              // Update existing health state
              const newHealth = Math.max(0, healthState.health - 1)
              console.log(`🩺 Updating health: ${healthState.health} -> ${newHealth}`)

              const { error: updateError } = await supabase
                .from("player_health_states")
                .update({
                  health: newHealth,
                  is_being_attacked: true,
                  last_attack_time: new Date().toISOString(),
                })
                .eq("player_id", currentPlayer.id)
                .eq("room_id", room.id)

              if (updateError) {
                console.error("❌ Error updating health state:", updateError)
              } else {
                console.log("✅ Health state updated successfully")
              }

              // Update player alive status if health reaches 0
              if (newHealth <= 0) {
                console.log("💀 Player eliminated - updating alive status")
                updates.is_alive = false
              }
            }

            // 4. Create attack event for host visualization
            const { error: attackError } = await supabase.from("player_attacks").insert({
              room_id: room.id,
              target_player_id: currentPlayer.id,
              damage: 1,
              attack_type: "wrong_answer",
              attack_data: {
                question_index: gameState.currentQuestion || 0,
                player_nickname: currentPlayer.nickname,
                answer_given: answer,
              },
            })

            if (attackError) {
              console.error("❌ Error creating attack event:", attackError)
            } else {
              console.log("✅ Attack event created for host visualization")
            }
          } catch (healthError) {
            console.error("❌ Error in health system:", healthError)
            // Don't fail the entire submission if health system fails
          }
        }

        // 5. Update player in database
        if (Object.keys(updates).length > 0) {
          const { error: playerError } = await supabase.from("players").update(updates).eq("id", currentPlayer.id)

          if (playerError) {
            console.error("❌ Error updating player stats:", playerError)
            // Don't return false, answer was submitted successfully
          } else {
            console.log("✅ Player stats updated successfully")
          }
        }

        console.log("🎯 Answer submission completed successfully")
        return true
      } catch (error) {
        console.error("❌ Critical error in submitAnswer:", error)
        return false
      } finally {
        if (isMountedRef.current) {
          setIsSubmitting(false)
        }
      }
    },
    [currentPlayer, room, gameState, isSubmitting],
  )

  const nextQuestion = useCallback(
    async (currentIndex: number) => {
      if (!room?.id || !gameState || isSubmitting) {
        console.log("nextQuestion: validation failed", {
          hasRoom: !!room?.id,
          hasGameState: !!gameState,
          isSubmitting,
        })
        return false
      }

      try {
        setIsSubmitting(true)
        console.log(`📝 Moving to next question: ${currentIndex} -> ${currentIndex + 1}`)

        const { error } = await supabase
          .from("game_states")
          .update({
            current_question: currentIndex + 1,
            time_remaining: 30,
          })
          .eq("room_id", room.id)

        if (error) {
          console.error("❌ Error updating question:", error)
          return false
        }

        console.log("✅ Question updated successfully")
        return true
      } catch (error) {
        console.error("❌ Error in nextQuestion:", error)
        return false
      } finally {
        if (isMountedRef.current) {
          setIsSubmitting(false)
        }
      }
    },
    [room, gameState, isSubmitting],
  )

  const startGame = useCallback(async () => {
    if (!room?.id || !currentPlayer?.isHost || isSubmitting) {
      return false
    }

    try {
      setIsSubmitting(true)

      // Update room status
      const { error: roomError } = await supabase
        .from("game_rooms")
        .update({
          status: "playing",
          current_phase: "quiz",
        })
        .eq("id", room.id)

      if (roomError) {
        console.error("Error starting game:", roomError)
        return false
      }

      // Update game state
      const { error: stateError } = await supabase
        .from("game_states")
        .update({
          phase: "quiz",
          current_question: 0,
          time_remaining: 30,
        })
        .eq("room_id", room.id)

      if (stateError) {
        console.error("Error updating game state:", stateError)
        return false
      }

      return true
    } catch (error) {
      console.error("Error in startGame:", error)
      return false
    } finally {
      if (isMountedRef.current) {
        setIsSubmitting(false)
      }
    }
  }, [room, currentPlayer, isSubmitting])

  const restartGame = useCallback(async () => {
    if (!room?.id || isSubmitting) {
      return false
    }

    try {
      setIsSubmitting(true)

      // Reset local state first
      if (isMountedRef.current) {
        setIsGameOver(false)
        setShowCaptureAnimation(false)
        setWrongAnswers(0)
      }

      // Reset room
      const { error: roomError } = await supabase
        .from("game_rooms")
        .update({
          status: "waiting",
          current_phase: "lobby",
        })
        .eq("id", room.id)

      if (roomError) {
        console.error("Error restarting room:", roomError)
        return false
      }

      // Reset game state
      const { error: stateError } = await supabase
        .from("game_states")
        .update({
          phase: "lobby",
          current_question: 0,
          time_remaining: 30,
          current_correct_answers: 0,
        })
        .eq("room_id", room.id)

      if (stateError) {
        console.error("Error resetting game state:", stateError)
        return false
      }

      // Reset all players
      const { error: playersError } = await supabase
        .from("players")
        .update({
          score: 0,
          correct_answers: 0,
          wrong_answers: 0,
          is_alive: true,
        })
        .eq("room_id", room.id)

      if (playersError) {
        console.error("Error resetting players:", playersError)
        return false
      }

      // Reset health states
      const { error: healthError } = await supabase.from("player_health_states").delete().eq("room_id", room.id)

      if (healthError) {
        console.error("Error resetting health states:", healthError)
        // Don't fail restart for this
      }

      return true
    } catch (error) {
      console.error("Error in restartGame:", error)
      return false
    } finally {
      if (isMountedRef.current) {
        setIsSubmitting(false)
      }
    }
  }, [room, isSubmitting])

  const leaveGame = useCallback(async () => {
    if (!currentPlayer?.id || !room?.id || isSubmitting) {
      return false
    }

    try {
      setIsSubmitting(true)

      const { error } = await supabase.from("players").delete().eq("id", currentPlayer.id)

      if (error) {
        console.error("Error leaving game:", error)
        return false
      }

      return true
    } catch (error) {
      console.error("Error in leaveGame:", error)
      return false
    } finally {
      if (isMountedRef.current) {
        setIsSubmitting(false)
      }
    }
  }, [currentPlayer, room, isSubmitting])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      isMountedRef.current = false
    }
  }, [])

  return {
    isGameOver,
    setIsGameOver,
    showCaptureAnimation,
    setShowCaptureAnimation,
    wrongAnswers,
    setWrongAnswers,
    isSubmitting,
    toggleReady,
    submitAnswer,
    nextQuestion,
    startGame,
    restartGame,
    leaveGame,
  }
}
